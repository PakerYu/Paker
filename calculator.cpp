#include "Snake2_1_0.h"


//??????
int toPixel(int Net)
{
	return Net * EdgeLenth + Border;
}


//??????????????????
struct Section* searchSection(int x)
{
	struct Section* p;

	if (abs(x) > Snake.length)
		return NULL;

	if (x >= 0)
	{
		//x??§³??0, ???????????
		p = head;
		while (p->num != x)
			NextSection(p);
	}
	else
	{
		//x§³??0, ??¦Â?????????
		p = tail;
		while (p->num != Snake.length+x)
			PreSection(p);
	}

	return p;
}

//??????????
void Period_Calculate(struct Refresh* info)
{
	//?????????????
	info->period.status = (long)(CLOCKS_PER_SEC / ((-pow(exp(1.0), -(Snake.length - OriginalLength) / 14.0) + 1) * 2.5 + 1.25));

	//??????????????
	info->period.screen = (long)(info->period.status * 0.7 / (1.0 * info->frequency));
	
}

/*
*?????þ—????????????????
* threshold: ???
* return: ???????
*/
int timeOffset(TimeRecord* x,clock_t threshold)
{
	x->latter_time = clock();
	if (x->latter_time - x->previous_time >= threshold)
	{
		x->previous_time = x->latter_time;
		return 1;
	}
	return 0;
}

//Section?????????(head?????????)
void directInherit(struct Section* p)
{
	/*
	* ????: ?????????????left, ????????? &left
	*		?????????? left, ?????? tail
	*/
	while (p->pre != NULL)
	{
		p->direction = p->pre->direction;
		p = p->pre;
	}

	//???????? head ??
	p->direction = Snake.direction;
}

/*
* ???????
* x: ??num?x??????????, x=-1???¦Â??
* return: ???????????????, ????????????
*/
struct Section* CreateSection(int x)
{
	struct Section* p, * left_side_section, * right_side_section;

	left_side_section = searchSection(x);

	right_side_section = left_side_section->next;

	p = (struct Section*)malloc(Section_Size);
	left_side_section->next = p;

	//????????
	p->pre = left_side_section;		//??????????
	p->next = right_side_section;	//??????????
	right_side_section->pre = p;	//?????????????

	//?????¦Â?????????, ????? tail ???????????
	if (x == -1)
		tail = p;

	//?????????
	p->num = Snake.length;
	p->direction = left->direction;
	p->x = left->x;
	p->y = left->y;

	//????????????¦Ë??
	p->Gx = toPixel(p->x);
	p->Gy = toPixel(p->y);
	

	Snake.length++;
	do
	{
		NextSection(p);
		p->num++;
	} while (p->next);

	return p;
}

/*
* ??????
* return: 1????????, 0????????
*/
int crashCheck()
{
	//????????
	if ((head->x < 0 || head->x >= xNet) ||
		(head->y < 0 || head->y >= yNet))
		return 1;

	struct Section* p = head;
	NextSection(p);
	do
	{
		if (head->x == p->x && head->y == p->y)
			return 1;

		NextSection(p);
	} while (p != left);

	return 0;
}

/*
* ???????????
* return: 1 ?????????, 0 ?????§Ô??
*/
int foodCheck()
{
	if (head->x == food.x && head->y == food.y)
		return 1;

	return 0;
}

//????????????§Ù???

/*
*???????(???????????)
* end_section: ???????????
*/
void coordinatesRefresh(struct Section* end_section)
{
	struct Section* p = head;
	while (1)
	{

		//????????????????????
		switch (p->direction)
		{
		case UP:	p->y -= 1;
			break;
		case DOWN:	p->y += 1;
			break;
		case LEFT:	p->x -= 1;
			break;
		case RIGHT:	p->x += 1;
		}

		//?§Ø???????????????, ???????
		if (p == end_section)
			break;

		NextSection(p);
	}
}


//??????????
void pixel_Compute_Print(struct Section* endSection)
{
	struct Section* p = endSection;
	while (1)
	{
		switch (p->direction)
		{
		case UP:
			p->Gy -= Anime.pixel_pre_step;
			break;
		case DOWN:
			p->Gy += Anime.pixel_pre_step;
			break;
		case LEFT:
			p->Gx -= Anime.pixel_pre_step;
			break;
		case RIGHT:
			p->Gx += Anime.pixel_pre_step;
		}
		SecPrint(p, WHITE);

		if (p->pre == NULL)
			break;

		PreSection(p);
	}
}